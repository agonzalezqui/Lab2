import math
import gmpy2

#1B
#https://www.cuemath.com/numbers/greatest-common-divisor-gcd/
def greatest_common_divisor(n1b, n2b):
    if n2b == 0:
        return n1b
    else:
        return greatest_common_divisor(n2b, n1b % n2b)

#2A
def p_q_factors(n):
	a=math.isqrt(n)+1
	temp=math.isqrt((a*a)-n)
	D1 = temp*temp
	D2 = ((a*a)-n)
	while not (D1 == D2):
		temp=math.isqrt((a*a)-n)
	s=temp
	p=a+s
	q=a-s
	print('First number: ', p, "\n")
	print('Second number: ', q, "\n")
	validation = p * q
	print('Validation: ', validation, "\n")
	return p,q

#2B




#3
#Wiener attack can successfully perform the factorization on the RSA modulus N and determine a private key d
#There is a standard way to generate a unique continued fraction from anyrational number. By the Euclidean division algorithm, 
#one can efficiently determine all the coefficients x0, x1,...,xn of the continued fraction
def continued_fractions(pkn, pke):
    #pkn -> possible key n
    #pke --> possible key e
    #euclidean division
    #result containing the floating-point value
    quotient  = pkn // pke
    remainder = pkn % pke
    expansion = []
    expansion.append(quotient)
    while remainder != 0:
        pkn = pke
        pke = remainder
        #euclidean division
        quotient  = pkn // pke
        remainder = pkn % pke
        expansion.append(quotient)
        #print(expansion)
    return expansion

#Source for convergets
#https://sagi.io/crypto-classics-wieners-rsa-attack/
def convergents(expansion):
    size = len(expansion)
    nom = []
    denom = []
    for convergents in range(size):
        #Rational Approximations
        if convergents  == 0:
            ni = expansion[convergents]
            di = 1
        elif convergents  == 1:
            ni = expansion[convergents]*expansion[convergents -1] + 1
            di = expansion[convergents]
        else:
            ni = expansion[convergents]*nom[convergents -1] + nom[convergents -2]
            di = expansion[convergents]*denom[convergents -1] + denom[convergents -2]
        nom.append(ni)
        denom.append(di)
        yield (ni, di)

def the_wiener_attack(e,n):
    continued_fractions_values = continued_fractions(e, n)
    for pk, dg in convergents(continued_fractions_values):
        if pk == 0:
            continue;           
        #result containing the floating-point value
        #having (N,e) known and (k,d) approximated, we can deduce φ(N)
        #Where φ(N) is Euler’s totient function
        phi_euler = (e * dg - 1) // pk
        if gmpy2.is_square(((n - phi_euler + 1) // 2) ** 2 - n):
            d = dg // (e * dg - phi_euler * pk)
            return d

if __name__ == '__main__':

    #print("Here starts 2A", "\n")
    #1B
    #n1b = 31911268879726153592906144654237027376295605122244213622922186521905706566982029803162058645560935018590239228741916856548386908451480921197559002999923682112215351653191056500861642292092542289871863948919769102322109592410256330920289755738830113897223085997490143812504556443250361624670954182290699884363278896117260513728011714272216191623720025058574339391161134427455844173649966802001084085434015788604264018240837235540669979791159665641798142182641260977245871174011676056877150506997452523149677619595362184722427839973069792800511461097543016106605185768856201137690019195422872853821674569617291045348689
    #n2b = 29749098234544950722553728915487736889032000866235439990224672856459603959762999494308747194494532325885995604229460732526748468701949483147742529416082853014150724439501812137763248341553329886209455926895906389466393931259187179345819618331695383131697541789713809171851909036255858913738517079097328136385803271665213396401797666719326659871515268852958442081564695126076615593690544933101179315724715313978155339567027899545964999201565586503260559560324485135168632732813082657924153077728565345736780910658086015188197891329991073146601336884478114205134885359752069712996903473839150213862565214367526184271213
    #b = greatest_common_divisor (n1b, n2b)
    #print("Greatest common divisor", b, "\n")

    #print("Here starts 2A", "\n")

    #2A
    n2a = 31401612687528177930215943148848809311518904648412623648220491560999134047133387404035404234173305721880604143039585486515317194864906548211258721186428317259772943399041454221743407594470620073977936497501994583009883533841277596103728165846101737491816806690067221463676885724449939022899923184989892421727241280596606832207507590947098792683744805374463880959093833448789884820082010758605737868798783718156918838115514573328254935242993005433365126264477751444026310666237744475957277386209631579355243316171072969461456495192594930326864442956512077580367920523056765040638774009742519469467742782525619657333117
    p_q_factors(n2a)

    print("Here starts 2B", "\n")
    #2B
    n2b = 61875236400720759128410941215016479453613282123198667331377016766603927665997397163220426786915195151825369038630953400078667423845632404763981470343566987098498301753730390857612122297550835849654828364670609996817002624295909462920344292561541752528241785063166635968063122355255895282785698082420903775939588824604266016368789475208111017418832511525901028776125518692455909759651215198842914354567118078839820318099544062552917457076588143545635889643240338175499881747347651885094368832196081331569182199150838190049066538477263421447352318440084507237101708052929374849609757243460785313196143175160485430252643
    p_q_factors(n2b)

    #print("Here starts 3", "\n")

    #3
    #n_3 = 31572253668946223368340157100721987766746218463736824783505635131921053880398741320644875421329504217933416422336918416263408538952177986508994175591182768950207147336188432455124667514201867376909227788134941323555902495049233601287696456816385455907725032886562051454322468668214625612317109993078620529639774616518443677804391408891641903175536847686030211632523660782037213447088479131269565204282324663517421706048402910651099744974056786727812991192176997050739471403369421617160003772289048267809022469915924569385942569022178774225834165571053657200129401052764120020877313983409004932571630004656678491554033
    #e_3 = 7084215194443599160339614321138928983214362269664400507990258691986234567347379532809700232256805715669899435125455589766395600413533503573822989102823878826540036317848245491834763460693299412011619210827311587500311657621439893147815582844814748650942186449787061150827753958225319378164169085724521950445516816392443392835946057362175733538556192411994505858592612662805711714449145899544166354660465794567570468563034819166109105798194936416549149864412218709017864526810122862155857826601574302659442260666643066114221374852104428425503135373985569499838251381802559047735816838596220653454921257900296590700089
    #d = the_wiener_attack(e_3,n_3)
    #print("Private exponent d: ", d)


